<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2-Approximation TSP Algorithm Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #buttons {
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            background-color: lightgray;
            cursor: not-allowed;
        }
        svg {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
        .point {
            fill: red;
            stroke: black;
            stroke-width: 1px;
        }
        .mst-edge {
            stroke: gray;
            stroke-width: 2px;
        }
        .considered-edge {
            stroke: orange;
            stroke: 2px;
            stroke-dasharray: 5,5;
        }
        .tsp-edge {
            stroke: blue;
            stroke-width: 2px;
        }
        .label {
            font-size: 12px;
            pointer-events: none;
        }
        .legend {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h2>2-Approximation TSP Algorithm (MST + Preorder)</h2>
        <svg id="svgCanvas" width="600" height="600"></svg>
        <div id="buttons">
            <button id="addMST">Add MST Edge</button>
            <button id="addTSP">Add TSP Edge</button>
            <button id="reset">Reset</button>
        </div>
    </div>

    <script>
        // Configuration
        const width = 600;
        const height = 600;
        const padding = 50;
        const nPoints = 10;
        const minDistance = 0.1;
        const maxAttempts = 10000;

        // State Variables
        let points = [];
        let distMatrix = [];
        let mstEdges = [];
        let mstSteps = [];
        let mstStepIndex = 0;
        let consideredEdges = [];
                let adjList = [];
        let preorderOrder = [];
        let tour = [];
        let tspStepIndex = 0;
        let mstLines = [];
        let tspLines = [];
        let labels = [];
        let legendAdded = false;

        // Create SVG Canvas
        const svg = d3.select("#svgCanvas")
                      .attr("width", width)
                      .attr("height", height);

        // Create a group for edges and points
        const edgeGroup = svg.append("g");
        const pointGroup = svg.append("g");
        const labelGroup = svg.append("g");

        // Create Legend
        const legend = svg.append("g")
                          .attr("class", "legend")
                          .attr("transform", `translate(${width - 150}, ${20})`)
                          .style("display", "none");

        legend.append("line")
              .attr("x1", 0).attr("y1", 0)
              .attr("x2", 20).attr("y2", 0)
              .attr("stroke", "gray")
              .attr("stroke-width", 2);
        legend.append("text")
              .attr("x", 25).attr("y", 5)
              .text("MST Edge");

        legend.append("line")
              .attr("x1", 0).attr("y1", 30)
              .attr("x2", 20).attr("y2", 30)
              .attr("stroke", "orange")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");
        legend.append("text")
              .attr("x", 25).attr("y", 35)
              .text("Considered Edge");

        legend.append("line")
              .attr("x1", 0).attr("y1", 60)
              .attr("x2", 20).attr("y2", 60)
              .attr("stroke", "blue")
              .attr("stroke-width", 2);
        legend.append("text")
              .attr("x", 25).attr("y", 65)
              .text("TSP Edge");

        // Utility Functions
        function generateRandomPoints(n, minDist, maxAttempts) {
            let pts = [];
            let attempts = 0;
            while (pts.length < n && attempts < maxAttempts) {
                let candidate = [Math.random(), Math.random()];
                let tooClose = pts.some(p => Math.hypot(candidate[0] - p[0], candidate[1] - p[1]) < minDist);
                if (!tooClose) {
                    pts.push(candidate);
                }
                attempts++;
            }
            if (pts.length < n) {
                throw new Error(`Failed to generate ${n} points with min distance ${minDist} after ${maxAttempts} attempts.`);
            }
            return pts;
        }

        function computeDistanceMatrix(pts) {
            let matrix = Array.from({length: pts.length}, () => Array(pts.length).fill(0));
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    let dist = Math.hypot(pts[i][0] - pts[j][0], pts[i][1] - pts[j][1]);
                    matrix[i][j] = dist;
                    matrix[j][i] = dist;
                }
            }
            return matrix;
        }

        function primMST(matrix) {
            const n = matrix.length;
            let inTree = Array(n).fill(false);
            let edgeHeap = [];
            let steps = [];
            let mst = [];

            inTree[0] = true;
            for (let j = 1; j < n; j++) {
                edgeHeap.push({cost: matrix[0][j], u: 0, v: j});
            }
            edgeHeap.sort((a, b) => a.cost - b.cost);

            let edgeCount = 0;
            while (edgeHeap.length > 0 && edgeCount < n - 1) {
                let edge = edgeHeap.shift();
                let {cost, u, v} = edge;
                let chosen = false;
                if (!inTree[v]) {
                    inTree[v] = true;
                    mst.push([u, v]);
                    edgeCount++;
                    chosen = true;
                    for (let w = 0; w < n; w++) {
                        if (!inTree[w]) {
                            edgeHeap.push({cost: matrix[v][w], u: v, v: w});
                        }
                    }
                    edgeHeap.sort((a, b) => a.cost - b.cost);
                }
                steps.push({u, v, chosen});
            }
            return {mst, steps};
        }

        function buildAdjacencyList(edges, n) {
            let adj = Array.from({length: n}, () => []);
            edges.forEach(([u, v]) => {
                adj[u].push(v);
                adj[v].push(u);
            });
            return adj;
        }

        function preorderTraversal(adj, start=0) {
            let visited = new Set();
            let order = [];
            function dfs(u) {
                visited.add(u);
                order.push(u);
                adj[u].forEach(v => {
                    if (!visited.has(v)) {
                        dfs(v);
                    }
                });
            }
            dfs(start);
            return order;
        }

        function createTourPath(order) {
            return [...order, order[0]];
        }

        // Initialization Function
        function initialize() {
            // Reset State
            mstEdges = [];
            mstSteps = [];
            mstStepIndex = 0;
            consideredEdges = [];
            adjList = [];
            preorderOrder = [];
            tour = [];
            tspStepIndex = 0;
            mstLines.forEach(line => line.remove());
            mstLines = [];
            tspLines.forEach(line => line.remove());
            tspLines = [];
            labels.forEach(label => label.remove());
            labels = [];
            edgeGroup.selectAll("*").remove();
            pointGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();
            legend.style("display", "none");

            // Generate Points
            try {
                points = generateRandomPoints(nPoints, minDistance, maxAttempts);
            } catch (e) {
                alert(e.message);
                return;
            }

            // Compute Distance Matrix
            distMatrix = computeDistanceMatrix(points);

            // Compute MST
            const {mst, steps} = primMST(distMatrix);
            mstEdges = mst;
            mstSteps = steps;

            // Build Adjacency List
            adjList = buildAdjacencyList(mstEdges, nPoints);

            // Preorder Traversal
            preorderOrder = preorderTraversal(adjList, 0);

            // Create Tour
            tour = createTourPath(preorderOrder);

            // Draw Points
            pointGroup.selectAll("circle")
                      .data(points)
                      .enter()
                      .append("circle")
                      .attr("class", "point")
                      .attr("cx", d => scaleX(d[0]))
                      .attr("cy", d => scaleY(d[1]))
                      .attr("r", 8);

            // Add Labels
            points.forEach((p, i) => {
                let label = labelGroup.append("text")
                                       .attr("class", "label")
                                       .attr("x", scaleX(p[0]) + 10)
                                       .attr("y", scaleY(p[1]) - 10)
                                       .text(` ${i}`);
                labels.push(label);
            });

            // Reset Buttons
            d3.select("#addMST").property("disabled", false).style("background-color", "");
            d3.select("#addTSP").property("disabled", false).style("background-color", "");
            d3.select("#reset").property("disabled", false);

            // Remove Legend
            legend.style("display", "none");
        }

        // Scaling Functions
        function scaleX(x) {
            return padding + x * (width - 2 * padding);
        }

        function scaleY(y) {
            return padding + y * (height - 2 * padding);
        }

        // Button Callbacks
        function addMSTEdge() {
            if (mstStepIndex >= mstSteps.length) return;

            const step = mstSteps[mstStepIndex];
            const {u, v, chosen} = step;

            // Draw considered edge
            const line = edgeGroup.append("line")
                                   .attr("class", "considered-edge")
                                   .attr("x1", scaleX(points[u][0]))
                                   .attr("y1", scaleY(points[u][1]))
                                   .attr("x2", scaleX(points[v][0]))
                                   .attr("y2", scaleY(points[v][1]))
                                   .attr("stroke", "orange")
                                   .attr("stroke-dasharray", "5,5")
                                   .attr("stroke-width", 2);
            consideredEdges.push(line);

            if (chosen) {
                // Replace considered edge with MST edge
                line.remove();
                consideredEdges.pop();
                const mstLine = edgeGroup.append("line")
                                          .attr("class", "mst-edge")
                                          .attr("x1", scaleX(points[u][0]))
                                          .attr("y1", scaleY(points[u][1]))
                                          .attr("x2", scaleX(points[v][0]))
                                          .attr("y2", scaleY(points[v][1]))
                                          .attr("stroke", "gray")
                                          .attr("stroke-width", 2);
                mstLines.push(mstLine);
            }

            mstStepIndex++;

            // If all MST steps are done, disable the button and show legend
            if (mstStepIndex === mstSteps.length) {
                d3.select("#addMST").property("disabled", true).style("background-color", "lightgray");
                showLegend();
            }
        }

        function addTSPEdge() {
            if (tspStepIndex >= tour.length -1) return;

            const u = tour[tspStepIndex];
            const v = tour[tspStepIndex +1];

            const tspLine = edgeGroup.append("line")
                                      .attr("class", "tsp-edge")
                                      .attr("x1", scaleX(points[u][0]))
                                      .attr("y1", scaleY(points[u][1]))
                                      .attr("x2", scaleX(points[v][0]))
                                      .attr("y2", scaleY(points[v][1]))
                                      .attr("stroke", "blue")
                                      .attr("stroke-width", 2);
            tspLines.push(tspLine);

            tspStepIndex++;

            // If all TSP steps are done, disable the button and show legend
            if (tspStepIndex === tour.length -1) {
                d3.select("#addTSP").property("disabled", true).style("background-color", "lightgray");
                showLegend();
            }
        }

        function resetVisualization() {
            initialize();
        }

        function showLegend() {
            if (!legendAdded) {
                legend.style("display", "block");
                legendAdded = true;
            }
        }

        // Attach Button Event Listeners
        d3.select("#addMST").on("click", addMSTEdge);
        d3.select("#addTSP").on("click", addTSPEdge);
        d3.select("#reset").on("click", resetVisualization);

        // Initial Setup
        initialize();
    </script>
</body>
</html>
